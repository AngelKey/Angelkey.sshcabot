import hashlib
import os
import subprocess
import time

import pytest

SUBTEAM = os.environ['SUBTEAM']
SUBTEAM_SECONDARY = os.environ['SUBTEAM_SECONDARY']
USERNAME = os.environ['KEYBASE_USERNAME']
BOT_USERNAME = os.environ['BOT_USERNAME']

# "uniquestring" is stored in /etc/unique of the SSH server. We then run the command `sha1sum /etc/unique` via kssh
# and assert that the output contains the sha1 hash of uniquestring. This checks to make sure the command given to
# kssh is actually executing on the remote server.
EXPECTED_HASH = hashlib.sha1(b"uniquestring").hexdigest().encode('utf-8')

def assert_contains_hash(output):
    assert EXPECTED_HASH in output

@pytest.fixture(autouse=True)
def run_around_tests():
    clear_keys()
    clear_local_config()
    # Calling yield triggers the test execution
    yield

def clear_keys():
    # Clear all keys generated by kssh
    try:
        run_command("rm -rf ~/.ssh/keybase-signed-key*")
    except subprocess.CalledProcessError:
        pass

def clear_local_config():
    # Clear kssh's local config file
    try:
        run_command("rm -rf ~/.ssh/kssh.config")
    except subprocess.CalledProcessError:
        pass

def simulate_two_teams(func):
    # A decorator that simulates running the given function in an environment with two teams set up
    def inner(*args, **kwargs):
        run_command(f"keybase fs read /keybase/team/{SUBTEAM}/kssh-client.config | sed 's/{SUBTEAM}/{SUBTEAM_SECONDARY}/g' | sed 's/{BOT_USERNAME}/otherbotname/g' | keybase fs write /keybase/team/{SUBTEAM_SECONDARY}/kssh-client.config")
        try:
            ret = func(*args, **kwargs)
        finally:
            run_command("keybase fs rm /keybase/team/%s/kssh-client.config" % SUBTEAM_SECONDARY)
        return ret
    return inner

def outputs_audit_log(expected_number):
    # A decorator that asserts that the given function triggers expected_number of audit logs to be added to '/mnt/ca.log'
    def decorator(func):
        def inner(*args, **kwargs):
            cnt = 0
            with open('/mnt/ca.log') as f:
                while f.readline():
                    # Read all lines of the audit log
                    pass
                # Then run the function
                ret = func(*args, **kwargs)
                # Then see if there are new lines
                TIMEOUT = 1
                start = time.time()
                while True:
                    line = f.readline()
                    if line and "Processing SignatureRequest from user=%s" % USERNAME in line and "principals:root, expiration:+1h, pubkey:ssh-ed25519" in line:
                        cnt += 1
                    time.sleep(0.1)
                    if time.time() - start > TIMEOUT:
                        break
                if cnt != expected_number:
                    assert False, "Found %s audit log entries, expected %s!" % (cnt, expected_number)
                return ret
        return inner
    return decorator

def run_command(cmd):
    return subprocess.check_output(cmd, shell=True)

@outputs_audit_log(expected_number=1)
def test_kssh():
    # Test the simple happy case
    assert_contains_hash(run_command("""bin/kssh -q -o StrictHostKeyChecking=no root@sshd "sha1sum /etc/unique" """))

@outputs_audit_log(expected_number=1)
def test_kssh_reuse():
    # Test that kssh reuses expired keys
    assert_contains_hash(run_command("""bin/kssh -q -o StrictHostKeyChecking=no root@sshd "sha1sum /etc/unique" """))
    start = time.time()
    assert_contains_hash(run_command("""bin/kssh -q -o StrictHostKeyChecking=no root@sshd "sha1sum /etc/unique" """))
    elapsed = time.time() - start
    assert elapsed < 0.75

@outputs_audit_log(expected_number=1)
def test_kssh_regenerate_expired_keys():
    # Test that kssh reprovisions a key when the stored keys are expired
    run_command("ls ~/")
    run_command("mv ~/tests/testFiles/expired ~/.ssh/keybase-signed-key-- && mv ~/tests/testFiles/expired.pub ~/.ssh/keybase-signed-key--.pub && mv ~/tests/testFiles/expired-cert.pub ~/.ssh/keybase-signed-key---cert.pub")
    assert_contains_hash(run_command("""bin/kssh -q -o StrictHostKeyChecking=no root@sshd "sha1sum /etc/unique" """))

@outputs_audit_log(expected_number=1)
def test_kssh_provision():
    # Test the `kssh --provision` flag
    # we have to run all of the below commands in one run_command call so that environment variables are shared
    # so ssh-agent can work
    output = run_command("""
    eval `ssh-agent -s`
    bin/kssh --provision
    ssh -q -o StrictHostKeyChecking=no root@sshd "sha1sum /etc/unique"
    echo -n foo > /tmp/foo
    scp /tmp/foo root@sshd:/tmp/foo
    ssh -q -o StrictHostKeyChecking=no root@sshd "sha1sum /tmp/foo"
    """)
    assert_contains_hash(output)
    assert hashlib.sha1(b"foo").hexdigest().encode('utf-8') in output

@outputs_audit_log(expected_number=0)
@simulate_two_teams
def test_kssh_errors_on_two_teams():
    # Test that kssh does not run if there are multiple teams, no client config, and no --team flag
    try:
        run_command("bin/kssh root@sshd")
        assert False
    except subprocess.CalledProcessError as e:
        assert b"Found 2 config files" in e.output

@outputs_audit_log(expected_number=1)
@simulate_two_teams
def test_kssh_team_flag():
    # Test that kssh works with the --team flag
    assert_contains_hash(run_command("bin/kssh --team %s -q -o StrictHostKeyChecking=no root@sshd 'sha1sum /etc/unique'" % SUBTEAM))

@outputs_audit_log(expected_number=1)
@simulate_two_teams
def test_kssh_set_default_team():
    # Test that kssh works with the --set-default-team flag
    run_command("bin/kssh --set-default-team %s" % SUBTEAM)
    assert_contains_hash(run_command("bin/kssh -q -o StrictHostKeyChecking=no root@sshd 'sha1sum /etc/unique'"))

@outputs_audit_log(expected_number=1)
@simulate_two_teams
def test_kssh_override_default_team():
    # Test that the --team flag overrides the local config file
    run_command("bin/kssh --set-default-team %s" % SUBTEAM_SECONDARY)
    assert_contains_hash(run_command("bin/kssh --team %s -q -o StrictHostKeyChecking=no root@sshd 'sha1sum /etc/unique'" % SUBTEAM))

def test_keybaseca_backup():
    # Test the keybaseca backup command by reading and verifying the private key stored in /mnt/cakey.backup
    run_command("mkdir -p /tmp/ssh/")
    run_command("chown -R keybase:keybase /tmp/ssh/")
    with open('/mnt/cakey.backup') as f:
        keyLines = []
        add = False
        for line in f:
            if "----" in line and "PRIVATE" in line and "BEGIN" in line:
                add = True
            if add:
                keyLines.append(line)
            if "----" in line and "PRIVATE" in line and "END" in line:
                add = False
    key = '\n'.join(keyLines)
    print(key)
    with open('/tmp/ssh/cakey', 'w+') as f:
        f.write(key)
    run_command("chmod 0600 /tmp/ssh/cakey")
    output = run_command("ssh-keygen -y -e -f /tmp/ssh/cakey")
    assert b"BEGIN SSH2 PUBLIC KEY" in output

def pytest_sessionfinish(session, exitstatus):
    # Automatically run after all tests in order to ensure that no kssh-client config files stick around
    run_command("keybase fs rm /keybase/team/%s/kssh-client.config || true" % SUBTEAM)
    run_command("keybase fs rm /keybase/team/%s/kssh-client.config || true" % SUBTEAM_SECONDARY)