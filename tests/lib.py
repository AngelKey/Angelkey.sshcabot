import hashlib
import os
import subprocess
import time

def run_command(cmd):
    return subprocess.check_output(cmd, shell=True)

def read_file(filename):
    """
    Read the contents of the given filename to a list of strings. If it is a normal file,
    uses the standard open() function. Otherwise, uses `keybase fs read`.
    :param filename:    The name of the file to read
    :return:            A list of lines in the file
    """
    if filename.startswith("/keybase/"):
        return run_command("keybase fs read %s" % filename).splitlines()
    with open(filename, 'rb') as f:
        return f.readlines()

def clear_keys():
    # Clear all keys generated by kssh
    try:
        run_command("rm -rf ~/.ssh/keybase-signed-key*")
    except subprocess.CalledProcessError:
        pass

def clear_local_config():
    # Clear kssh's local config file
    try:
        run_command("rm -rf ~/.ssh/kssh.config")
    except subprocess.CalledProcessError:
        pass

def simulate_two_teams(func):
    # A decorator that simulates running the given function in an environment with two teams set up
    def inner(*args, **kwargs):
        run_command("keybase fs cp /keybase/team/%s.ssh/kssh-client.config /keybase/team/%s/kssh-client.config" % (os.environ['SUBTEAM'], os.environ['SUBTEAM_SECONDARY']))
        try:
            ret = func(*args, **kwargs)
        finally:
            run_command("keybase fs rm /keybase/team/%s/kssh-client.config" % os.environ['SUBTEAM_SECONDARY'])
        return ret
    return inner

def outputs_audit_log(filename, expected_number):
    # A decorator that asserts that the given function triggers expected_number of audit logs to be added to '/keybase/team/team.ssh.prod/ca.log'
    # Note that fuse is not running in the container so this has to use `keybase fs read`
    def decorator(func):
        def inner(*args, **kwargs):
            cnt = 0
            username = os.environ.get('KEYBASE_USERNAME', None)

            # Make a set of the lines in the audit log before we ran
            before_lines = set(read_file(filename))

            # Then run the function
            ret = func(*args, **kwargs)

            # And sleep to give KBFS some time
            time.sleep(1.5)

            # Then see if there are new lines using set difference. This is only safe/reasonable since we include a
            # timestamp in audit log lines.
            after_lines = set(read_file(filename))
            new_lines = after_lines - before_lines

            for line in new_lines:
                line = line.decode('utf-8')
                if line and "Processing SignatureRequest from user=%s" % username in line and "principals:staging,root_everywhere, expiration:+1h, pubkey:ssh-ed25519" in line:
                    cnt += 1

            if cnt != expected_number:
                assert False, "Found %s audit log entries, expected %s!" % (cnt, expected_number)
            return ret
        return inner
    return decorator

# "uniquestring" is stored in /etc/unique of the SSH server. We then run the command `sha1sum /etc/unique` via kssh
# and assert that the output contains the sha1 hash of uniquestring. This checks to make sure the command given to
# kssh is actually executing on the remote server.
EXPECTED_HASH = hashlib.sha1(b"uniquestring").hexdigest().encode('utf-8')

def assert_contains_hash(output):
    assert EXPECTED_HASH in output
